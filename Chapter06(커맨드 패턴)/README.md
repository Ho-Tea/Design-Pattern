# 💈디자인 패턴 (#싱글턴 패턴)
***
  

### ☑️싱글턴 패턴에 대해 알아보자  
<br/>

## 📌 특정 클래스에 객체 인스턴스가 하나만 만들어지도록 해주는 패턴
  
<br/>

## <정의> 
<img src="imagefile/1.png">


- **어디서든 그 인스턴스에 접근할 수 있도록 전역 접근 지점을 제공한다**
- 하나의 인스턴스로 이루어 진다

<br/>

--------------

<br/>


## <멀티 쓰레딩 문제>   

<img src="imagefile/2.png">

<br/>


### 해결방안 (enum을 사용하지 않고 싱글턴 패턴을 구현하는 방법)
  - `getInstance()`메소드 동기화 하기
    - <img src="imagefile/4.png">
  - 인스턴스가 필요할 때는 생성하지 말고 처음부터 만든다
    ```java
    public class Singleton{
      private static Singleton uniqueInstance = new Singleton();

      private Singleton() {}

      public static Singleton getInstance() {
        return uniqueInstance;
      }
    }
    ```
  - DCL을 써서 `getInstance()`에서 동기화 되는 부분을 줄입니다
    - DCL : Double - Check - Locking
    - <img src="imagefile/3.png">




<br/>


--------------------------------------


## <싱글턴 패턴의 문제점>
  - 리플렉션,직렬화,역직렬화 문제가 될 수 있다
  - 느슨한 결합을 위배한다
  - 한클래스가 1가지일만 해야하는 객체지향의 관점에서 벗어난다
  - 클래스로더와 관련된 문제 발생

<br/>

## <이러한 싱글턴 패턴의 문제점들에 대한 해결방안>
  - <img src="imagefile/5.png">

<br/>

-----------------------

## 💥마치며..  

- 싱글턴 패턴 : 하나의 인스턴스

<br/>

__⭕상황에 맞게 변경할 수 있는 **유연한** 디자인을 만드는게 중요!!!__

<br/>

### <📦객체지향의 기초>
- 추상화
- 캡슐화
- 다형성
- 상속

<br/>


### <📦객체지향의 원칙(🍀디자인원칙🍀)>
- 바뀌는 부분은 캡슐화한다. -> **관리의 용이성**
    - 달라지는 부분과 달라지지 않는 부분을 분리
- 상속보다는 구성을 활용한다 -> **재사용성**
    - ex)`Interface I;` 변수사용 (상속을 사용하는 것이 아닌)
- 구현보다는 인터페이스에 맞춰서 프로그래밍 한다. -> **확장성**
    - GOF원칙, 인터페이스를 이용하자!
- 상호작용하는 객체 사이에서는 가능하면 느슨한 결합을 사용해야한다 -> **재사용성, 유연성**
    - 인터페이스를 구현하는 객체를 만들면 느슨한 결합을 만들기 수월<br>(확장성이 높고 의존성이 낮다)
- 클래스는 확장에는 열려 있어야 하지만 변경에는 닫혀 있어야 한다
  - OCP : 기존코드 수정없이 행동을 확장한다 (**행동을 상속받는 것이 아닌**) 
  - **구성** (**슈퍼클래스인 인스턴스변수로 연결**)과 위임으로 객체의 행동 확장으로 실행중에 동적으로 행동 설정 가능<br>ex)`this.Beverage = Beverage;`
- 추상화된 것에 의존하게 만들고 구상클래스에 의존하지 않게 만든다
  - 구상클래스가 아닌 추상클래스와 인터페이스에 맞춰서 코딩 -> 느슨한결합, 캡슐화
  - `Pizza인터페이스(or추상클래스)`라는 추상에 의존하게 만들자
- +) 더 추가될 예정


<br/>


